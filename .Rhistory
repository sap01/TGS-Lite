packrat::status()
install.packages('bnstruct')
packrat::status()
packrat::snapshot()
packrat::status()
install.packages('rjson')
install.packages('minet')
source("https://bioconductor.org/biocLite.R")
biocLite("minet")
packrat::status()
install.packages('bnlearn')
packrat::status()
install.packages(c('R6', 'RBGL', 'Rcpp', 'RcppArmadillo', 'RcppEigen', 'Rgraphviz', 'RoughSets', 'catnet', 'curl', 'devtools', 'digest', 'doParallel', 'doSNOW', 'foreach', 'functional', 'gRain', 'gRbase', 'ggm', 'git2r', 'graph', 'httr', 'iterators', 'jsonlite', 'memoise', 'mime', 'openssl', 'randomForest', 'rstudioapi', 'snow', 'whisker', 'withr'))
packrat::status()
packrat::snapshot()
biocLite("graph")
packrat::status()
biocLite('Rgraphviz')
packrat::status()
biocLite('RBGL')
packrat::status()
packrat::snapshot()
packrat::snapshot()
packrat::status()
lm1 <- lm(Fertility ~ . , data = swiss)
lm1
BIC(lm1)
AIC(lm1)
x <- 1:5
lmx <- lm(x ~ 1)
logLik(lmx)
library(bnlearn)
ls()
rm(list=ls())
ls()
data(learning.test)
res = set.arc(gs(learning.test), "A", "B")
res
modelstring(res)
res2 = model2network(modelstring(res))
res2
all.equal(res, res2)
arcs(res)
bnlearn::arcs(res)
next.candidate.src.node.set <- list('B', 'C')
next.candidate.src.node.set
curr.tgt.node <- 'A'
tgt.node <- 'A'
paste('[', tgt.node, '|')
paste('[', tgt.node, '|', sep = '')
next.modelstring <- paste('[', tgt.node, '|', sep = '')
next.modelstring <- paste(next.modelstring, ']', sep = '')
next.modelstring
print(next.candidate.src.node.set)
list('a','b','c')[[1:2]]
list('a','b','c')
tl <- list('a','b','c')
for (item in tl) print(item)
tgt.node <- 'A'
curr.candidate.src.node.set <- list('B', 'C')
curr.modelstring <- paste('[', tgt.node, '|', sep = '')
if (length(curr.candidate.src.node.set) > 0) {
src.modelstring <- '' curr.candidate.src.node.set[[1]]
if (length(curr.candidate.src.node.set) > 1) {
for (list.idx in 2:length(curr.candidate.src.node.set)) {
src.modelstring <- paste(src.modelstring, ':', src.node.name, sep = '')
}
rm(src.node.name)
}
}
curr.modelstring <- paste(next.modelstring, ']', sep = '')
curr.modelstring <- paste('[', tgt.node, '|', sep = '')
if (length(curr.candidate.src.node.set) > 0) {
src.modelstring <- curr.candidate.src.node.set[[1]]
if (length(curr.candidate.src.node.set) > 1) {
for (list.idx in 2:length(curr.candidate.src.node.set)) {
src.modelstring <- paste(src.modelstring, ':', src.node.name, sep = '')
}
rm(src.node.name)
}
}
curr.modelstring <- paste(curr.modelstring, src.modelstring, ']', sep = '')
curr.modelstring <- paste('[', tgt.node, '|', sep = '')
if (length(curr.candidate.src.node.set) > 0) {
src.modelstring <- curr.candidate.src.node.set[[1]]
if (length(curr.candidate.src.node.set) > 1) {
for (list.idx in 2:length(curr.candidate.src.node.set)) {
src.modelstring <- paste(src.modelstring, ':', curr.candidate.src.node.set[[list.idx]], sep = '')
}
rm(src.node.name)
}
}
curr.modelstring <- paste(curr.modelstring, src.modelstring, ']', sep = '')
curr.modelstring
q()
packrat::init()
packrat::status()
packrat::restore()
install.packages('Matrix')
packrat::restore()
install.packages('codetools')
packrat::restore()
packrat::status()
.libPaths()
install.packages('Matrix')
packrat::status()
.libPaths()
packrat::on()
.libPaths()
packrat::status()
install.packages('Matrix')
packrat::status()
install.packages('codetools')
packrat::status()
.libPaths()
packrat::snapshot()
packrat::status()
q()
(FALSE, 3)
as.list(FALSE, 3)
as.list(rep(FALSE, 3))
tl <- as.list(rep(FALSE, 3))
tl
as.vector(tl)
c(tl)
Vectorize(tl)
unlist(tl)
library(bnlearn)
packrat::status()
data("learning.test")
dim(learning.test)
colnames(learning.test)
bnlearn::score('F', learning.test, type = 'bic')
bnlearn::score('[A][B]', learning.test, type = 'bic')
bnlearn::score('[A][B][C][D][E][F]', learning.test, type = 'bic')
ms <- '[A][B][C][D][E][F]'
t.net <- bnlearn::model2network(ms)
bnlearn::score(t.net, learning.test, type = 'bic')
ms <- '[F]'
t.net <- bnlearn::model2network(ms)
bnlearn::score(t.net, learning.test, type = 'bic')
paste(c(), '[A]')
paste(c(), '[A]', sep = '')
paste(c(), '[v1]', sep = '')
list(FALSE, TRUE)
length(tl)
tl[[length(tl)]]
tv <- 1:3
for (i in 3:1) print(tv[i])
rm(i)
sum(TRUE, FALSE)
sum(TRUE, FALSE, TRUE)
intToBits(2)
!FALSE & !FALSE
tv
for (i in tv) print(i)
tv2 <- c('v1_t1', 'v2_t1', 'v3_t1')
for (i in tv2) print(i)
tv[tl]
tv[unlist(tl)]
tl
tl[[2]] <- TRUE
tv[unlist(tl)]
tv2[unlist(tl)]
tl[[1]]<- TRUE
tl[[3]]<- TRUE
tl[[2]]<- FALSE
tv2[unlist(tl)]
packrat::status()
packrat::status()
packrat::on()
tl
tv
tv2
tl2 <- tl
tl2[[tl2]] <- FALSE
tl2[[]] <- FALSE
tl2[[1, 3]] <- FALSE
tl2[[C(1,3)]] <- FALSE
tl2[[1]] <- FALSE
tl2[[3]] <- FALSE
TL2
tl2
tv2[unlist(tl)]
tv2[unlist(tl2)]
length(tv2[unlist(tl2)])
as.list(tv2[unlist(tl2)])
as.list(tv2[unlist(tl)])
as.list(tv2[unlist(tl2)])
length(as.list(tv2[unlist(tl2)]))
packrat::status()
library(bnlearn)
t.net
ms
rm(i)
ms <- '[A][B][C][D][E][F]'
ms <- '[A][B][C][D][E][F|A:B]'
t.net <- bnlearn::model2network(ms)
score(t.net, learning.test, type = 'bic')
str(learning.test)
sample(1:2, 16, replace = TRUE)
matrix(sample(1:2, 16, replace = TRUE), nrow = 4, ncol = 4)
t.data <- matrix(sample(1:2, 16, replace = TRUE), nrow = 4, ncol = 4)
colnames(t.data)[1:3] <- tv2
colnames(t.data) <- c(tv2, 'v1_t2')
t.data
str(t.data)
t.data2 <- as.data.frame(t.data)
str(t.data2)
t.data3 <- as.factor(t.data2)
str(t.data3)
t.data3 <- t.data2
for (i in 1:4) {
t.data3[, i] <- as.factor(t.data3[, i])
}
rm(i)
str(t.data2)
